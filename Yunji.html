<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;" name="viewport" />
	<title>Yunji</title>
	<style type="text/css">
		body {background: #f0f0f0;}
		a:hover {color: #272;}
		ul {margin: 0;padding: 0;display: flex; flex-direction: row;}
		li {width: 100%;height: 40px;text-align: center;line-height: 40px;margin: 0 4px;padding:0 4px;list-style: none;position:relative;}
		div {width: 100%; min-height: 200px; border: 1px solid #272; border-radius: 6px; margin-top: 20px;}
		div > p {display: none;padding: 5px;}
		.line {color: DarkCyan;}
		.line:after {
		 	content: "  ";	
            position: absolute;
            left: 0;
            bottom: 0;
            width: 100%;
            height: 1px;
            background-color: #272; /* 如果不用 background-color, 使用 border-top:1px solid #f00; 效果是一样的*/
            -webkit-transform: scaleY(.5);
            transform:scaleY(.5);
		}
	</style>
</head>
<body>
	<ul>
		<li class="line">attr和prop</li>
		<li class="">0.5边框</li>
		<li>首屏加载速度优化方案</li>
		<li>keep alive</li>
	</ul>
	<pre>
		<div>
			<p style="display: block;">
				在高版本的jquery引入prop方法后，什么时候该用prop？什么时候用attr？它们两个之间有什么区别？这些问题就出现了。 <br/><br/>
				关于它们两个的区别，网上的答案很多。这里谈谈我的心得，我的心得很简单： <br/>
						对于HTML元素本身就带有的固有属性，在处理时，使用prop方法。 <br/>
						对于HTML元素我们自己自定义的DOM属性，在处理时，使用attr方法。 <br/>
														 <br/>
														 <br/>
				prop()函数的结果: <br/>
				      1.如果有相应的属性，返回指定属性值。 <br/>
				      2.如果没有相应的属性，返回值是空字符串。 <br/>
				attr()函数的结果: <br/>
				      1.如果有相应的属性，返回指定属性值。 <br/>
				      2.如果没有相应的属性，返回值是undefined。 <br/>
	 															<br/>
				对于HTML元素本身就带有的固有属性，在处理时，使用prop方法。 <br/>
				对于HTML元素我们自己自定义的DOM属性，在处理时，使用attr方法。 <br/>
				具有 true 和 false 两个属性的属性，如 checked, selected 或者 disabled 使用prop() <br/>
		 	</p>
			<p><a href="https://www.cnblogs.com/sese/p/7067961.html" title="" target="blank">CSS3实现0.5px的边框</a></p>
			<p>
				使用CDN资源,减小服务器带宽压力
				路由懒加载: 
				<a href="https://segmentfault.com/a/1190000011426274" target="blank" title="">vue的路由懒加载和组件的按需加载</a>

				我们可以在router中进行配置, 实现组件的按需加载, 在一些单个组件文件较大的时候, 
				采用按需加载能够减少build.js的体积, 优化加载速度(如果组件的体积较小, 那么采用按需加载会增加额外的http请求, 反倒增加了加载时间)
				
			</p>
			<p>
				在搭建 vue 项目时，有某些组件没必要多次渲染，所以需要将组件在内存中进行‘持久化’，此时 &lt;keep-alive&gt; 便可以派上用场了。 
				&lt;keep-alive&gt; 可以使被包含的组件状态维持不变，即便是组件切换了，其内的状态依旧维持在内存之中。在下一次显示时，也不会重现渲染。
				<code>
					&lt;keep-alive :include="['ListView', 'DetailView']"&gt;
					  &lt;router-view /&gt;
					&lt;/keep-alive&gt;
				</code>

			</p>
		</div>

		<!-- 
			1. webpack打包原理: 把所有依赖打包成一个 bundle.js 文件，通过代码分割成单元片段并按需加载。
			2. loader用于加载某些资源文件。因为webpack本身只能打包common.js规范的js文件，对于其他资源如css，img等，是没有办法加载的，这时就需要对应的loader将资源转化，从而进行加载。
			4.什么是bundle，什么是chunk，什么是module
					bundle：是由webpack打包出来的文件
					chunk：是指webpack在进行模块依赖分析的时候，代码分割出来的代码块
					module：是开发中的单个模块
		 -->
	</pre>
	<script src="https://cdn.bootcss.com/jquery/1.12.1/jquery.js"></script>
	<script type="text/javascript">
		// JQ写法
		$('body').on('click', 'ul li',function (item, index) {
			var index = $(this).index()
			$(this).addClass('line').siblings().removeClass('line')
			$('div p').eq(index).show().siblings().hide()
		})


		// 原生js
		// var btns = document.getElementsByTagName('li'),
		// 	ps = document.getElementsByTagName('p'),
		// 	len = btns.length
		// for (var i = 0; i < len; ++i) {
		// 	(function (n) {
		// 		btns[n].onclick = function () {
		// 			for (var j = 0; j < len; ++j) {
		// 				btns[j].className = ''
		// 				ps[j].style.display = 'none'
		// 			}
		// 			this.className = 'line'
		// 			console.log(this.innerHTML)
		// 			ps[n].style.display = 'block'
		// 		}
		// 	}(i))
		// }

		// ES6 数组去重
		let arr = [1,1,1,1,1,1,2,2,2,2,2]
		let myArr = Array.from(new Set(arr))
		console.log(myArr)
		// ES5 数组去重
		var arr2 = [1,1,1,1,1,2,2,2,2,2]
		Array.prototype.uniqe = function () {
			var len = this.length,
				temp = {},
				arr = []
			for (var i = 0; i < len; ++ i) {
				if (!temp[this[i]]) {
					temp[this[i]] = 'a'
					arr.push(this[i])
				}
			}
			return arr
		}
		console.log(arr2.uniqe())


		// 问 福利情况和晋升制度
	</script>
</body>
</html>